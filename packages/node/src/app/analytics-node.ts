import {
  EventProperties,
  Traits,
  Emitter,
  CoreAnalytics,
  CoreContext,
  CorePlugin,
  EventFactory,
  EventQueue,
  dispatchAndEmit,
  Integrations,
  CoreOptions,
  Callback,
  CoreSegmentEvent,
  bindAll,
  PriorityQueue,
} from '@segment/analytics-core'
import { validation } from '@segment/analytics-plugin-validation'

import { analyticsNode, AnalyticsNodePluginSettings } from './plugin'

import { version } from '../../package.json'

/** create a derived class since we may want to add node specific things to Context later  */
export class NodeContext extends CoreContext {}

type IdentityOptions =
  | { userId: string; anonymousId?: string }
  | { userId?: string; anonymousId: string }

export type NodeSegmentEventOptions = CoreOptions

/**
 * Map of emitter event names to method args.
 */
type NodeEmitterEvents = {
  error: [ctx: CoreContext]
  initialize: [AnalyticsSettings]
  alias: [ctx: CoreContext]
  track: [ctx: CoreContext]
  identify: [ctx: CoreContext]
  page: [ctx: CoreContext]
  screen: NodeEmitterEvents['page']
  group: [ctx: CoreContext]
  register: [pluginNames: string[]]
  deregister: [pluginNames: string[]]
}

type NodeSegmentEventType = 'track' | 'page' | 'identify' | 'alias' | 'screen'

export interface NodeSegmentEvent extends CoreSegmentEvent {
  type: NodeSegmentEventType
  options?: NodeSegmentEventOptions
}

export interface AnalyticsSettings {
  writeKey: string
  timeout?: number
  plugins?: CorePlugin[]
  integrations?: Integrations
  retryQueue?: boolean
}

export interface InitOptions {
  integrations?: Integrations
  retryQueue?: boolean
}

export class AnalyticsNode
  extends Emitter<NodeEmitterEvents>
  implements CoreAnalytics
{
  private _eventFactory: EventFactory
  private _retryQueue?: boolean
  private _integrations: Integrations

  queue: EventQueue

  ready: Promise<void>

  constructor(settings: AnalyticsSettings) {
    super()
    this._retryQueue = settings.retryQueue
    this._integrations = settings.integrations ?? {}
    this._eventFactory = new EventFactory()
    this.queue = new EventQueue(new PriorityQueue(3, []))

    const nodeSettings: AnalyticsNodePluginSettings = {
      name: 'analytics-node-next',
      type: 'after',
      version: 'latest',
      writeKey: settings.writeKey,
    }

    this.ready = this.register(validation, analyticsNode(nodeSettings))
      .then(() => undefined)
      .catch((err) => {
        console.error(err)
      })

    this.emit('initialize', settings)

    bindAll(this)
  }

  get VERSION() {
    return version
  }

  /**
   * Combines two unassociated user identities.
   * @link https://segment.com/docs/connections/sources/catalog/libraries/server/node/#alias
   */
  alias({
    userId,
    previousId,
    options,
    callback,
  }: {
    /* The new user id you want to associate with the user. */
    userId: string
    /* The previous id that the user was recognized by (this can be either a userId or an anonymousId). */
    previousId: string
    options?: NodeSegmentEventOptions
    callback?: Callback
  }): void {
    const segmentEvent = this._eventFactory.alias(
      userId,
      previousId,
      options,
      this._integrations
    )
    dispatchAndEmit(segmentEvent, this.queue, this, {
      callback: callback,
      retryQueue: this._retryQueue,
    }).catch(() => {})
  }

  /**
   * Associates an identified user with a collective.
   *  @link https://segment.com/docs/connections/sources/catalog/libraries/server/node/#group
   */
  group({
    /* 	The ID of the group. */
    groupId,
    /* The ID for this user in your database. Note: at least one of userId or anonymousId must be included in any group call. */
    userId,
    /* An ID associated with the user when you donâ€™t know who they are (eg., the anonymousId generated by analytics.js). Note: at least one of userId or anonymousId must be included in any group call. */
    anonymousId,
    traits = {},
    options = {},
    callback,
  }: {
    groupId: string
    traits?: Traits
    options?: NodeSegmentEventOptions
    callback?: Callback
  } & IdentityOptions): void {
    const segmentEvent = this._eventFactory.group(
      groupId,
      traits,
      { ...options, anonymousId, userId },
      this._integrations
    )

    dispatchAndEmit(segmentEvent, this.queue, this, {
      callback,
    }).catch(() => {})
  }

  /**
   * Includes a unique userId and (maybe anonymousId) and any optional traits you know about them.
   * @link https://segment.com/docs/connections/sources/catalog/libraries/server/node/#identify
   */
  identify({
    userId,
    anonymousId,
    traits = {},
    options,
    callback,
  }: {
    traits?: Traits
    options?: NodeSegmentEventOptions
    callback?: Callback
  } & IdentityOptions): void {
    const segmentEvent = this._eventFactory.identify(
      userId,
      traits,
      { ...options, anonymousId, userId },
      this._integrations
    )

    dispatchAndEmit(segmentEvent, this.queue, this, {
      callback,
    }).catch(() => {})
  }

  /**
   * The page method lets you record page views on your website, along with optional extra information about the page being viewed.
   * @link https://segment.com/docs/connections/sources/catalog/libraries/server/node/#page
   */
  page({
    userId,
    anonymousId,
    category,
    name,
    properties,
    options,
    timestamp,
    callback,
  }: IdentityOptions & {
    /*  The category of the page. Useful for cases like ecommerce where many pages might live under a single category. */
    category?: string
    /* The name of the page.*/
    name?: string
    /* A dictionary of properties of the page. */
    properties?: EventProperties
    callback?: Callback
    timestamp?: string | Date
    options?: CoreOptions
  }): void {
    const segmentEvent = this._eventFactory.page(
      category ?? null,
      name ?? null,
      properties,
      { ...options, anonymousId, userId, timestamp },
      this._integrations
    )

    dispatchAndEmit(segmentEvent, this.queue, this, {
      callback,
    }).catch(() => {})
  }

  /**
   * Records screen views on your app, along with optional extra information
   * about the screen viewed by the user.
   *
   * TODO: This is not documented on the segment docs ATM (for node).
   */
  screen({
    userId,
    anonymousId,
    category,
    name,
    properties,
    options,
    callback,
    timestamp,
  }: Parameters<AnalyticsNode['page']>[0]): void {
    const segmentEvent = this._eventFactory.screen(
      category ?? null,
      name ?? null,
      properties,
      { ...options, anonymousId, userId, timestamp },
      this._integrations
    )

    dispatchAndEmit(segmentEvent, this.queue, this, {
      callback,
    }).catch(() => {})
  }

  /**
   * Records actions your users perform.
   * @link https://segment.com/docs/connections/sources/catalog/libraries/server/node/#track
   */
  track({
    userId,
    anonymousId,
    event,
    properties,
    options,
    callback,
  }: IdentityOptions & {
    event: string
    properties?: EventProperties
    options?: NodeSegmentEventOptions
    callback?: Callback
  }): void {
    const segmentEvent = this._eventFactory.track(
      event,
      properties,
      { ...options, userId, anonymousId },
      this._integrations
    )

    dispatchAndEmit(segmentEvent, this.queue, this, {
      callback,
    }).catch(() => {})
  }

  /**
   * Registers one or more plugins to augment Analytics functionality.
   * @param plugins
   */
  async register(...plugins: CorePlugin<any, any>[]): Promise<void> {
    return this.queue.criticalTasks.run(async () => {
      const ctx = NodeContext.system()

      const registrations = plugins.map((xt) =>
        this.queue.register(ctx, xt, this)
      )
      await Promise.all(registrations)
      this.emit(
        'register',
        plugins.map((el) => el.name)
      )
    })
  }

  /**
   * Deregisters one or more plugins based on their names.
   * @param pluginNames - The names of one or more plugins to deregister.
   */
  async deregister(...pluginNames: string[]): Promise<void> {
    const ctx = CoreContext.system()

    const deregistrations = pluginNames.map(async (pl) => {
      const plugin = this.queue.plugins.find((p) => p.name === pl)
      if (plugin) {
        return this.queue.deregister(ctx, plugin, this)
      } else {
        ctx.log('warn', `plugin ${pl} not found`)
      }
    })

    await Promise.all(deregistrations)
    this.emit('deregister', pluginNames)
  }
}
